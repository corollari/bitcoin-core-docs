<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>zmq</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel='shortcut icon' href='favicon.png' />
</head>
<body>
<h1 id="block-and-transaction-broadcasting-with-zeromq">Block and Transaction Broadcasting with ZeroMQ</h1>
<p><a href="https://zeromq.org/">ZeroMQ</a> is a lightweight wrapper around TCP connections, inter-process communication, and shared-memory, providing various message-oriented semantics such as publish/subscribe, request/reply, and push/pull.</p>
<p>The Bitcoin Core daemon can be configured to act as a trusted "border router", implementing the bitcoin wire protocol and relay, making consensus decisions, maintaining the local blockchain database, broadcasting locally generated transactions into the network, and providing a queryable RPC interface to interact on a polled basis for requesting blockchain related data. However, there exists only a limited service to notify external software of events like the arrival of new blocks or transactions.</p>
<p>The ZeroMQ facility implements a notification interface through a set of specific notifiers. Currently there are notifiers that publish blocks and transactions. This read-only facility requires only the connection of a corresponding ZeroMQ subscriber port in receiving software; it is not authenticated nor is there any two-way protocol involvement. Therefore, subscribers should validate the received data since it may be out of date, incomplete or even invalid.</p>
<p>ZeroMQ sockets are self-connecting and self-healing; that is, connections made between two endpoints will be automatically restored after an outage, and either end may be freely started or stopped in any order.</p>
<p>Because ZeroMQ is message oriented, subscribers receive transactions and blocks all-at-once and do not need to implement any sort of buffering or reassembly.</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>The ZeroMQ feature in Bitcoin Core requires the ZeroMQ API &gt;= 4.0.0 <a href="https://github.com/zeromq/libzmq/releases">libzmq</a>. For version information, see <a href="dependencies.html">dependencies.html</a>. Typically, it is packaged by distributions as something like <em>libzmq3-dev</em>. The C++ wrapper for ZeroMQ is <em>not</em> needed.</p>
<p>In order to run the example Python client scripts in the <code>contrib/zmq/</code> directory, one must also install <a href="https://github.com/zeromq/pyzmq">PyZMQ</a> (generally with <code>pip install pyzmq</code>), though this is not necessary for daemon operation.</p>
<h2 id="enabling">Enabling</h2>
<p>By default, the ZeroMQ feature is automatically compiled in if the necessary prerequisites are found. To disable, use --disable-zmq during the <em>configure</em> step of building bitcoind:</p>
<pre><code>$ ./configure --disable-zmq (other options)
</code></pre>
<p>To actually enable operation, one must set the appropriate options on the command line or in the configuration file.</p>
<h2 id="usage">Usage</h2>
<p>Currently, the following notifications are supported:</p>
<pre><code>-zmqpubhashtx=address
-zmqpubhashblock=address
-zmqpubrawblock=address
-zmqpubrawtx=address
-zmqpubsequence=address
</code></pre>
<p>The socket type is PUB and the address must be a valid ZeroMQ socket address. The same address can be used in more than one notification.</p>
<p>The option to set the PUB socket's outbound message high water mark (SNDHWM) may be set individually for each notification:</p>
<pre><code>-zmqpubhashtxhwm=n
-zmqpubhashblockhwm=n
-zmqpubrawblockhwm=n
-zmqpubrawtxhwm=n
-zmqpubsequencehwm=address
</code></pre>
<p>The high water mark value must be an integer greater than or equal to 0.</p>
<p>For instance:</p>
<pre><code>$ bitcoind -zmqpubhashtx=tcp://127.0.0.1:28332 \
           -zmqpubrawtx=ipc:///tmp/bitcoind.tx.raw \
           -zmqpubhashtxhwm=10000
</code></pre>
<p>Each PUB notification has a topic and body, where the header corresponds to the notification type. For instance, for the notification <code>-zmqpubhashtx</code> the topic is <code>hashtx</code> (no null terminator) and the body is the transaction hash (32 bytes) for all but <code>sequence</code> topic. For <code>sequence</code>, the body is structured as the following based on the type of message:</p>
<pre><code>&lt;32-byte hash&gt;C :                 Blockhash connected
&lt;32-byte hash&gt;D :                 Blockhash disconnected
&lt;32-byte hash&gt;R&lt;8-byte LE uint&gt; : Transactionhash removed from mempool for non-block inclusion reason
&lt;32-byte hash&gt;A&lt;8-byte LE uint&gt; : Transactionhash added mempool
</code></pre>
<p>Where the 8-byte uints correspond to the mempool sequence number.</p>
<p>These options can also be provided in bitcoin.conf.</p>
<p>ZeroMQ endpoint specifiers for TCP (and others) are documented in the <a href="http://api.zeromq.org/4-0:_start">ZeroMQ API</a>.</p>
<p>Client side, then, the ZeroMQ subscriber socket must have the ZMQ_SUBSCRIBE option set to one or either of these prefixes (for instance, just <code>hash</code>); without doing so will result in no messages arriving. Please see <a href="/contrib/zmq/zmq_sub.py"><code>contrib/zmq/zmq_sub.py</code></a> for a working example.</p>
<p>The ZMQ_PUB socket's ZMQ_TCP_KEEPALIVE option is enabled. This means that the underlying SO_KEEPALIVE option is enabled when using a TCP transport. The effective TCP keepalive values are managed through the underlying operating system configuration and must be configured prior to connection establishment.</p>
<p>For example, when running on GNU/Linux, one might use the following to lower the keepalive setting to 10 minutes:</p>
<p>sudo sysctl -w net.ipv4.tcp_keepalive_time=600</p>
<p>Setting the keepalive values appropriately for your operating environment may improve connectivity in situations where long-lived connections are silently dropped by network middle boxes.</p>
<h2 id="remarks">Remarks</h2>
<p>From the perspective of bitcoind, the ZeroMQ socket is write-only; PUB sockets don't even have a read function. Thus, there is no state introduced into bitcoind directly. Furthermore, no information is broadcast that wasn't already received from the public P2P network.</p>
<p>No authentication or authorization is done on connecting clients; it is assumed that the ZeroMQ port is exposed only to trusted entities, using other means such as firewalling.</p>
<p>Note that for <code>*block</code> topics, when the block chain tip changes, a reorganisation may occur and just the tip will be notified. It is up to the subscriber to retrieve the chain from the last known block to the new tip. Also note that no notification will occur if the tip was in the active chain--as would be the case after calling invalidateblock RPC. In contrast, the <code>sequence</code> topic publishes all block connections and disconnections.</p>
<p>There are several possibilities that ZMQ notification can get lost during transmission depending on the communication type you are using. Bitcoind appends an up-counting sequence number to each notification which allows listeners to detect lost notifications.</p>
<p>The <code>sequence</code> topic refers specifically to the mempool sequence number, which is also published along with all mempool events. This is a different sequence value than in ZMQ itself in order to allow a total ordering of mempool events to be constructed.</p>
</body>
</html>
